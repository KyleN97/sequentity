/*

Tools
-----

A "tool" or "tool context" represents a mode within which
input is handled. Tools are the primary mechanism with
which users interact with your data. 

*/

#include <vector>
#include <array>

struct Tooltip { const char* text; };

namespace Tool {

enum class Type : std::uint8_t {
    Select,
    DragSelect,
    LassoSelect,

    Translate,
    Rotate,
    Scale,

    Scrub,
};

enum class Device : std::uint8_t {
    Mouse,
    Keyboard,
    Gamepad,
    Touch,
    WacomPen,
    WacomTouch,
};

// From e.g. Wacom tablet
struct InputPressure  { float strength; };
struct InputPitch  { float angle; };
struct InputYaw  { float angle; };

// From e.g. Mouse or WASD keys
struct InputPosition2D  {
    Position absolute { 0, 0 };
    Position relative { 0, 0 };
    Position delta { 0, 0 };
};

struct InputPosition3D {
    Position absolute { 0, 0 };
    Position relative { 0, 0 };
};

// From e.g. WASD keys or D-PAD on XBox controller
enum class InputDirection2D : std::uint8_t { Left = 0, Up, Right, Down };
enum class InputDirection3D : std::uint8_t { Left = 0, Up, Right, Down, Forward, Backward };


/**
 * @brief Application data generated by these tools
 *
 * In addition to each Sequentity event, there is also our internal
 * application data, carried by events via a void*
 *
 */
struct EventData {
    Type type;
    
    // Keep track of where input starts in out input map
    int start { 0 };
    Position origin { 0, 0 };
    std::unordered_map<int, InputPosition2D> input;
};


// Possible event types
enum EventType : Sequentity::EventType {
    InvalidEvent = 0,  // Catch uninitialised types

    SelectEvent,
    LassoSelectEvent,
    DragSelectEvent,

    TranslateEvent,
    RotateEvent,
    ScaleEvent,

    ScrubEvent,

    MousePressEvent,
    MouseMoveEvent,
    MouseReleaseEvent,
    KeyPressEvent,
    KeyReleaseEvent,

    ToolEvent,
};


enum State : std::uint8_t {
    ToolState_None = 0,
    ToolState_Activated,
    ToolState_Active,
    ToolState_Deactivated
};


static const char* tooltype_to_char(Type type) {
    return type == Type::Select ? "Type::Select" :
           type == Type::Translate ? "Type::Translate" :
           type == Type::Rotate ? "Type::Rotate" :
           type == Type::Scale ? "Type::Scale" :
           type == Type::Scrub ? "Type::Scrub" :
                                 "Type::Unknown";
}


static const char* eventtype_to_char(EventType type) {
    return type == SelectEvent ? "SelectEvent" :
           type == TranslateEvent ? "TranslateEvent" :
           type == RotateEvent ? "RotateEvent" :
           type == ScaleEvent ? "ScaleEvent" :
           type == ScrubEvent ? "ScrubEvent" :
                                "UnknownEvent";
}


struct Context {
    virtual inline auto type() const -> Type = 0;
    virtual inline auto eventType() const -> EventType = 0;
    virtual inline auto name() const -> const char* = 0;
    virtual inline auto copy() const -> Context* = 0;
    virtual inline auto canRecord() const -> bool { return false; }

    virtual void setup() {}
    virtual void teardown();

    virtual auto begin(entt::entity subject, InputPosition2D input) -> bool;
    virtual auto update(InputPosition2D input) -> bool { return false; }
    virtual auto update(entt::entity subject, InputPosition2D input) -> bool;
    virtual auto finish() -> bool;

    // Signals
    virtual void abort();

    // Getters
    virtual inline auto color() const -> ImVec4 { return ImColor::HSV(0.0f, 0.75f, 0.75f); }
    inline auto subject() const -> entt::entity { return _subject; }
    inline auto input() const -> InputPosition2D { return _input; }
    inline auto state() const -> State { return _state; }

protected:
    entt::entity    _subject { entt::null };
    InputPosition2D _input { 0, 0 };
    State           _state { ToolState_None };
};


using Ptr = std::unique_ptr<Context>;
using Collection = std::unordered_map<int, Ptr>;


// Boilerplate
auto Context::begin(entt::entity subject, InputPosition2D input) -> bool {
    _subject = subject;
    _input = input;
    _state = ToolState_Activated;

    Registry.reset<Selected>();

    // Did the user click on an empty area?
    if (Registry.valid(subject)) {
        Registry.assign<Selected>(subject);
        return true;
    }

    return false;
}


bool Context::update(entt::entity subject, InputPosition2D input) {
    _subject = subject;
    _input = input;
    _state = ToolState_Activated;

    return update(input);
}


auto Context::finish() -> bool {
    bool can_record = Registry.valid(_subject);

    _subject = entt::null;
    _state = ToolState_Deactivated;

    return can_record;
}


void Context::teardown() {
    // Handle case of user switching tool in the middle of updating
    if (_state == ToolState_Active) finish();
}


void Context::abort() {
    _state = ToolState_None;
    _subject = entt::null;
}


struct Recorder {
    void begin(const Context& tool, int time) {
        auto [name, color] = Registry.get<Name, Color>(tool.subject());

        if (!Registry.has<Sequentity::Track>(tool.subject())) {
            Registry.assign<Sequentity::Track>(tool.subject(), name.text, color);
        }

        auto origin = Registry.get<Position>(tool.subject());
        auto* data = new EventData{}; {
            data->start = time;
            data->input[time] = tool.input();
            data->type = tool.type();
            data->origin = origin;
        }

        auto& track = Registry.get<Sequentity::Track>(tool.subject());
        bool is_new_channel = !Sequentity::HasChannel(track, tool.eventType());
        auto& channel = Sequentity::PushChannel(track, tool.eventType());

        if (is_new_channel) {
            channel.label = tool.name();
            channel.color = tool.color();
            channel.type = tool.eventType();

            Debug() << "Creating a new tool for this channel";
            channel.data = static_cast<void*>(tool.copy());
        }

        Sequentity::PushEvent(channel, {
            time,
            1,          /* length= */
            color,
            tool.eventType(),
            static_cast<void*>(data),
        });
    }

    void update(const Context& tool, int time) {
        auto& track = Registry.get<Sequentity::Track>(tool.subject());
        
        if (!track.channels.count(tool.eventType())) {
            Warning() << "This is a tool bug";
            return;
        }

        auto& channel = track.channels[tool.eventType()];
        auto& event = channel.events.back();

        auto data = static_cast<EventData*>(event.data);

        // Update existing data
        data->input[time] = tool.input();
        event.length = time - event.time + 1;
    }

    void finish(const Context& tool) {

    }
};



/**
 * @brief The simplest possible tool
 *
 *
 */
struct SelectContext : public Context {
    inline Type type() const override  { return Type::Select; }
    inline EventType eventType() const override  { return SelectEvent; }
    inline const char* name() const override  { return "Select"; }
    inline ImVec4 color() const override  { return ImColor::HSV(0.0f, 0.75f, 0.75f); }
    inline Context* copy() const override { return new SelectContext{}; }
};


struct ScrubContext : public Context {
    inline Type type() const override  { return Type::Scrub; }
    inline EventType eventType() const override  { return ScrubEvent; }
    inline const char* name() const override  { return "Scrub"; }
    inline Context* copy() const override { return new ScrubContext{}; }

    void setup() override {
        auto& state = Registry.ctx<ApplicationState>();
        _was_playing = state.playing;
        state.playing = false;

        Context::setup();
    }

    bool update(InputPosition2D input) override {
        if (_state == ToolState_Activated) {
            Registry.ctx<Sequentity::State>().current_time += input.delta.x;
        }

        return false;
    }

    void teardown() {
        auto& state = Registry.ctx<ApplicationState>();
        state.playing = _was_playing;
    }

private:
    bool _was_playing { false };
};



/**
 * @brief Translate an entity
 *
 *      __________ 
 *     |          |
 *     |          | ----------->   
 *     |          |
 *     |__________|
 *
 *
 */
struct TranslateContext : public Context {
    inline Type type() const override  { return Type::Translate; }
    inline EventType eventType() const override  { return TranslateEvent; }
    inline const char* name() const override  { return "Translate"; }
    inline ImVec4 color() const override { return ImColor::HSV(0.0f, 0.75f, 0.75f); }
    inline Context* copy() const override { return new TranslateContext{}; }
    virtual inline auto canRecord() const -> bool { return true; }

    void setup() {
        Debug() << "Setting Translate mouse cursor..";
        Debug() << "Setting Translate tool tips..";
    }

    bool update(InputPosition2D input) override {
        Registry.reset<Tooltip>();

        if (Registry.valid(_subject)) {
            if (!Registry.has<MoveIntent>(_subject)) {
                Registry.assign<MoveIntent>(_subject, input.delta.x, input.delta.y);

            } else {
                auto& intent = Registry.get<MoveIntent>(_subject);
                intent.x += input.delta.x;
                intent.y += input.delta.y;
            }

            _input = input;
            _state = ToolState_Active;

            return true;
        }

        else {
            // Let the user know what happens once clicked
            Registry.view<Hovered>().each([](auto entity, const auto) {
                Registry.assign<Tooltip>(entity, "Drag to translate");
            });

            _state = ToolState_None;
            return false;
        }
    }
};


/**
 * @brief Rotate an entity
 *                  __
 *      __________     \
 *     |          |     v
 *     |          |   
 *     |          |
 *     |__________|
 *  ^
 *   \___
 *
 */
struct RotateContext : public Context {
    inline Type type() const override  { return Type::Rotate; }
    inline EventType eventType() const override  { return RotateEvent; }
    inline const char* name() const override  { return "Rotate"; }
    inline ImVec4 color() const override { return ImColor::HSV(0.33f, 0.75f, 0.75f); }
    inline Context* copy() const override { return new RotateContext{}; }
    virtual inline auto canRecord() const -> bool { return true; }

    bool update(InputPosition2D input) override {
        Registry.reset<Tooltip>();

        if (Registry.valid(_subject)) {
            if (!Registry.has<RotateIntent>(_subject)) {
                Registry.assign<RotateIntent>(_subject, input.delta.x);

            } else {
                auto& intent = Registry.get<RotateIntent>(_subject);
                intent.angle += input.delta.x;
            }

            _state = ToolState_Active;
            _input = input;

            return true;
        }

        else {
            // Let the user know what happens once clicked
            Registry.view<Hovered>().each([](auto entity, const auto) {
                Registry.assign<Tooltip>(entity, "Drag to rotate");
            });

            _state = ToolState_None;
        }

        return false;
    }
};



/**
 * @brief Scale an entity
 *
 *   \              /
 *    \ __________ /
 *     |          |
 *     |          |
 *     |          |
 *     |__________|
 *    /            \
 *   /              \
 *
 */
struct ScaleContext : public Context {
    inline Type type() const override  { return Type::Scale; }
    inline EventType eventType() const override  { return ScaleEvent; }
    inline const char* name() const override  { return "Scale"; }
    inline ImVec4 color() const override { return ImColor::HSV(0.52f, 0.75f, 0.50f); }
    inline Context* copy() const override { return new ScaleContext{}; }
    virtual inline auto canRecord() const -> bool { return true; }

    bool update(InputPosition2D input) override {
        Registry.reset<Tooltip>();

        if (Registry.valid(_subject)) {
            if (!Registry.has<ScaleIntent>(_subject)) {
                Registry.assign<ScaleIntent>(_subject, input.delta.x);

            } else {
                auto& intent = Registry.get<ScaleIntent>(_subject);
                intent.scale += input.delta.x;
            }

            _state = ToolState_Active;
            _input = input;

            return true;
        }

        else {
            // Let the user know what happens once clicked
            Registry.view<Hovered>().each([](auto entity, const auto) {
                Registry.assign<Tooltip>(entity, "Drag to scale");
            });

            _state = ToolState_None;
        }

        return false;
    }
};

}