/*

Tools
-----

A "tool" or "tool context" represents a mode within which
input is handled. Tools are the primary mechanism with
which users interact with your data. 

*/

#include <vector>
#include <array>

struct Tooltip { const char* text; };

enum class ToolType : std::uint8_t {
    Select,
    DragSelect,
    LassoSelect,

    Translate,
    Rotate,
    Scale,

    Scrub,
};

// From e.g. Wacom tablet
struct InputPressure  { float strength; };
struct InputPitch  { float angle; };
struct InputYaw  { float angle; };

// From e.g. Mouse or WASD keys
struct InputPosition2D  {
    Position absolute { 0, 0 };
    Position relative { 0, 0 };
    Position delta { 0, 0 };
};

struct InputPosition3D {
    Position absolute { 0, 0 };
    Position relative { 0, 0 };
};

// From e.g. WASD keys or D-PAD on XBox controller
enum class InputDirection2D : std::uint8_t { Left = 0, Up, Right, Down };
enum class InputDirection3D : std::uint8_t { Left = 0, Up, Right, Down, Forward, Backward };


/**
 * @brief Application data generated by these tools
 *
 * In addition to each Sequentity event, there is also our internal
 * application data, carried by events via a void*
 *
 */
struct TranslateEventData {
    Position offset;
    std::vector<Position> positions;
};

struct RotateEventData {
    std::vector<int> orientations;
};

struct ScaleEventData {
    std::vector<int> scales;
};

struct ScrubEventData {
    std::vector<int> deltas;
};

struct ToolEventData {
    ToolType type;
    
    // Keep track of where input starts in out input map
    int start { 0 };
    Position origin { 0, 0 };
    std::unordered_map<int, InputPosition2D> input;
};


// Possible event types
enum EventType : Sequentity::EventType {
    InvalidEvent = 0,  // Catch uninitialised types

    SelectEvent,
    LassoSelectEvent,
    DragSelectEvent,

    TranslateEvent,
    RotateEvent,
    ScaleEvent,

    ScrubEvent,

    MousePressEvent,
    MouseMoveEvent,
    MouseReleaseEvent,
    KeyPressEvent,
    KeyReleaseEvent,

    ToolEvent,
};

enum ToolState : std::uint8_t {
    ToolState_None = 0,
    ToolState_Activated,
    ToolState_Active,
    ToolState_Deactivated
};


struct ToolContext {
    virtual inline ToolType type() const = 0;
    virtual inline EventType eventType() const = 0;
    virtual inline const char* name() const = 0;
    virtual inline ImVec4 color() const { return ImColor::HSV(0.0f, 0.75f, 0.75f); }

    virtual void setup() {}
    virtual void begin(entt::entity entity, InputPosition2D input) {
        _subject = entity;
        _input = input;
        _state = ToolState_Activated;

        Registry.reset<Selected>();
        Registry.assign<Selected>(entity);
    }

    virtual bool update(InputPosition2D) { return false; }

    bool update(entt::entity entity, InputPosition2D input) {
        _subject = entity;
        _state = ToolState_Activated;
        return update(input);
    }

    virtual void preview() {}
    virtual void finish() {
        _subject = entt::null;
        _state = ToolState_Deactivated;
    }

    virtual void teardown() {
        // Handle case of user switching tool in the middle of updating
        if (_state == ToolState_Active) finish();
    }


    void abort() {
        _state = ToolState_None;
        _subject = entt::null;
    }

    inline entt::entity subject() const { return _subject; }
    inline InputPosition2D input() const { return _input; }
    inline ToolState state() const { return _state; }

protected:
    ToolState _state { ToolState_None };

    int _begin_time { 0 };
    entt::entity _subject { entt::null };
    InputPosition2D _input { 0, 0 };
};


// TODO: Recording is called at different times for the same tool
//       and need to pass the event amongst themselves. This is ugly.
static entt::entity ACTIVE_EVENT { entt::null };


void record_tool(const ToolContext& tool, int time) {
    if (!tool.state()) return;

    if (tool.state() == ToolState_Activated) {
		Debug() << "About to create a new event..";
        const auto& [name, origin, color] = Registry.get<Name, Position, Color>(tool.subject());

        // Test for entities
        entt::entity track_entity { entt::null };
        entt::entity channel_entity { entt::null };
        entt::entity event_entity { entt::null };

        // Find existing track
        Events.view<Sequentity::Track>().each([&](auto entity, const auto& track_) {
            if (track_.owner == tool.subject()) {
                track_entity = entity;
            }
        });

        if (track_entity == entt::null) {
            track_entity = Events.create();

            Events.assign<Sequentity::Track>(track_entity);

            auto& track_ = Events.get<Sequentity::Track>(track_entity);
            track_.label = name.text;
            track_.color = color;
            track_.owner = tool.subject();

            // Tracks need an order consistent with the external scene hierarchy
            // TODO: This seems inefficient
            auto index = Registry.get<Index>(tool.subject());
            Events.assign<Index>(track_entity, index);

            Events.sort<Sequentity::Track>([](const entt::entity lhs, const entt::entity rhs) {
                return Events.get<Index>(lhs) < Events.get<Index>(rhs);
            });

            Debug() << "Created new track '" << track_.label << "'";
        }

        assert(Events.has<Sequentity::Track>(track_entity));
        auto& track_ = Events.get<Sequentity::Track>(track_entity);
        
        // Find existing channel
        Events.view<Sequentity::Channel>().each([&](auto entity, const auto& channel_) {
            if (channel_.owner == track_entity && channel_.type == tool.eventType()) {
                channel_entity = entity;
            }
        });

        if (channel_entity == entt::null) {
            channel_entity = Events.create();
            auto& channel_ = Events.assign<Sequentity::Channel>(channel_entity);
            channel_.label = tool.name();
            channel_.color = tool.color();
            channel_.owner = track_entity;
            channel_.type = tool.eventType();

            // TODO: I don't like storing entities in another entity.
            track_.children.push_back(channel_entity);

            // We need channels to have a consistent order across tracks
            // TODO: This doesn't look very efficient
            std::sort(track_.children.begin(),track_.children.end(), [](const entt::entity lhs,
                                                                        const entt::entity rhs) -> bool {
                return Events.get<Sequentity::Channel>(lhs).type < Events.get<Sequentity::Channel>(rhs).type;
            });

            Debug() << "Creating new channel '" << channel_.label << "'";
		}

        assert(Events.has<Sequentity::Channel>(channel_entity));
        auto& channel_ = Events.get<Sequentity::Channel>(channel_entity);

        Debug() << "Creating new event..";
        event_entity = Events.create();
        auto& event = Events.assign<Sequentity::Event>(event_entity);
        event.time = time;
        event.length = 1;
        event.color = color;
        event.owner = channel_entity;

        // Store all available input with this event
        Events.assign<InputPosition2D>(event_entity, tool.input());
        auto& data = Events.assign<ToolEventData>(event_entity);
        data.start = time;
        data.input[time] = tool.input();
        data.type = tool.type();
        data.origin = origin;

        channel_.children.push_back(event_entity);

        ACTIVE_EVENT = event_entity;
    }

    else if (tool.state() == ToolState_Active) {
        auto event_entity = ACTIVE_EVENT;
        if (event_entity == entt::null) {
            Debug() << "It's null..";
        } else {
            // Update event
            auto& event = Events.get<Sequentity::Event>(event_entity);
            event.length = time - event.time + 1;

            // Update payload
            auto& payload = Events.get<ToolEventData>(event_entity);
            payload.input[time] = tool.input();
        }
    }

    else if (tool.state() == ToolState_Deactivated) {
        Debug() << "..end";
    }
}



/**
 * @brief The simplest possible tool
 *
 *
 */
struct SelectContext : public ToolContext {
    inline ToolType type() const override  { return ToolType::Select; }
    inline EventType eventType() const override  { return SelectEvent; }
    inline const char* name() const override  { return "Select"; }
    inline ImVec4 color() const override  { return ImColor::HSV(0.0f, 0.75f, 0.75f); }
};


struct ScrubContext : public ToolContext {
    inline ToolType type() const override  { return ToolType::Scrub; }
    inline EventType eventType() const override  { return ScrubEvent; }
    inline const char* name() const override  { return "Scrub"; }
};



/**
 * @brief Translate an entity
 *
 *      __________ 
 *     |          |
 *     |          | ----------->   
 *     |          |
 *     |__________|
 *
 *
 */
struct TranslateContext : public ToolContext {
    inline ToolType type() const override        { return ToolType::Translate; }
    inline EventType eventType() const override  { return TranslateEvent; }
    inline const char* name() const override     { return "Translate"; }
    inline ImVec4 color() const override         { return ImColor::HSV(0.0f, 0.75f, 0.75f); }

    void setup() {
        Debug() << "Setting Translate mouse cursor..";
        Debug() << "Setting Translate tool tips..";
    }

    bool update(InputPosition2D input) {
        Registry.reset<Tooltip>();

        if (Registry.valid(_subject)) {
            if (!Registry.has<MoveIntent>(_subject)) {
                Registry.assign<MoveIntent>(_subject, input.delta.x, input.delta.y);

            } else {
                auto& intent = Registry.get<MoveIntent>(_subject);
                intent.x += input.delta.x;
                intent.y += input.delta.y;
            }

            _state = ToolState_Active;
            _input = input;

            return true;
        }

        else {
            // Let the user know what happens once clicked
            Registry.view<Hovered>().each([](auto entity, const auto) {
                Registry.assign<Tooltip>(entity, "Drag to translate");
            });

            _state = ToolState_None;
        }

        return false;
    }
};


/**
 * @brief Rotate an entity
 *                  __
 *      __________     \
 *     |          |     v
 *     |          |   
 *     |          |
 *     |__________|
 *  ^
 *   \___
 *
 */
struct RotateContext : public ToolContext {
    inline ToolType type() const override  { return ToolType::Rotate; }
    inline EventType eventType() const override  { return RotateEvent; }
    inline const char* name() const override  { return "Rotate"; }
    inline ImVec4 color() const override { return ImColor::HSV(0.33f, 0.75f, 0.75f); }

    bool update(InputPosition2D input) {
        Registry.reset<Tooltip>();

        if (Registry.valid(_subject)) {
            if (!Registry.has<RotateIntent>(_subject)) {
                Registry.assign<RotateIntent>(_subject, input.delta.x);

            } else {
                auto& intent = Registry.get<RotateIntent>(_subject);
                intent.angle += input.delta.x;
            }

            _state = ToolState_Active;
            _input = input;

            return true;
        }

        else {
            // Let the user know what happens once clicked
            Registry.view<Hovered>().each([](auto entity, const auto) {
                Registry.assign<Tooltip>(entity, "Drag to rotate");
            });

            _state = ToolState_None;
        }

        return false;
    }
};



/**
 * @brief Scale an entity
 *
 *   \              /
 *    \ __________ /
 *     |          |
 *     |          |
 *     |          |
 *     |__________|
 *    /            \
 *   /              \
 *
 */
struct ScaleContext : public ToolContext {
    inline ToolType type() const override  { return ToolType::Scale; }
    inline EventType eventType() const override  { return ScaleEvent; }
    inline const char* name() const override  { return "Scale"; }
    inline ImVec4 color() const override { return ImColor::HSV(0.52f, 0.75f, 0.50f); }

    bool update(InputPosition2D input) {
        Registry.reset<Tooltip>();

        if (Registry.valid(_subject)) {
            if (!Registry.has<ScaleIntent>(_subject)) {
                Registry.assign<ScaleIntent>(_subject, input.delta.x);

            } else {
                auto& intent = Registry.get<ScaleIntent>(_subject);
                intent.scale += input.delta.x;
            }

            _state = ToolState_Active;
            _input = input;

            return true;
        }

        else {
            // Let the user know what happens once clicked
            Registry.view<Hovered>().each([](auto entity, const auto) {
                Registry.assign<Tooltip>(entity, "Drag to scale");
            });

            _state = ToolState_None;
        }

        return false;
    }
};
