/*

Tools
-----

A "tool" or "tool context" represents a mode within which
input is handled. Tools are the primary mechanism with
which users interact with your data. 

*/

#include <vector>
#include <array>

struct Tooltip { const char* text; };

enum class ToolType : std::uint8_t {
    Select,
    DragSelect,
    LassoSelect,

    Translate,
    Rotate,
    Scale,

    Scrub,
};

// From e.g. Wacom tablet
struct InputPressure  { float strength; };
struct InputPitch  { float angle; };
struct InputYaw  { float angle; };

// From e.g. Mouse or WASD keys
struct InputPosition2D  {
    Position absolute { 0, 0 };
    Position relative { 0, 0 };
    Position delta { 0, 0 };
};

struct InputPosition3D {
    Position absolute { 0, 0 };
    Position relative { 0, 0 };
};

// From e.g. WASD keys or D-PAD on XBox controller
enum class InputDirection2D : std::uint8_t { Left = 0, Up, Right, Down };
enum class InputDirection3D : std::uint8_t { Left = 0, Up, Right, Down, Forward, Backward };


/**
 * @brief Application data generated by these tools
 *
 * In addition to each Sequentity event, there is also our internal
 * application data, carried by events via a void*
 *
 */
struct TranslateEventData {
    Position offset;
    std::vector<Position> positions;
};

struct RotateEventData {
    std::vector<int> orientations;
};

struct ScaleEventData {
    std::vector<int> scales;
};

struct ScrubEventData {
    std::vector<int> deltas;
};

struct ToolEventData {
    ToolType type;
    
    // Keep track of where input starts in out input map
    int start { 0 };
    Position origin { 0, 0 };
    std::unordered_map<int, InputPosition2D> input;
};


// Possible event types
enum EventType : Sequentity::EventType {
    InvalidEvent = 0,  // Catch uninitialised types

    SelectEvent,
    LassoSelectEvent,
    DragSelectEvent,

    TranslateEvent,
    RotateEvent,
    ScaleEvent,

    ScrubEvent,

    MousePressEvent,
    MouseMoveEvent,
    MouseReleaseEvent,
    KeyPressEvent,
    KeyReleaseEvent,

    ToolEvent,
};

enum ToolState : std::uint8_t {
    ToolState_None = 0,
    ToolState_Activated,
    ToolState_Active,
    ToolState_Deactivated
};


struct ToolContext {
    virtual inline ToolType type() const = 0;
    virtual inline EventType eventType() const = 0;
    virtual inline const char* name() const = 0;
    virtual inline ImVec4 color() const { return ImColor::HSV(0.0f, 0.75f, 0.75f); }

    virtual void setup() {}
    virtual void begin(entt::entity entity, InputPosition2D input) {
        _subject = entity;
        _input = input;
        _state = ToolState_Activated;

        Registry.reset<Selected>();
        Registry.assign<Selected>(entity);
    }

    virtual bool update(InputPosition2D) { return false; }

    bool update(entt::entity entity, InputPosition2D input) {
        _subject = entity;
        _state = ToolState_Activated;
        return update(input);
    }

    virtual void preview() {}
    virtual void finish() {
        _subject = entt::null;
        _state = ToolState_Deactivated;
    }

    virtual void teardown() {
        // Handle case of user switching tool in the middle of updating
        if (_state == ToolState_Active) finish();
    }


    void abort() {
        _state = ToolState_None;
        _subject = entt::null;
    }

    inline entt::entity subject() const { return _subject; }
    inline InputPosition2D input() const { return _input; }
    inline ToolState state() const { return _state; }

protected:
    ToolState _state { ToolState_None };

    int _begin_time { 0 };
    entt::entity _subject { entt::null };
    InputPosition2D _input { 0, 0 };
};


void record_tool(const ToolContext& tool, int time) {
    if (!tool.state()) return;

    if (tool.state() == ToolState_Activated) {
        auto [name, color] = Registry.get<Name, Color>(tool.subject());

        if (!Registry.has<Sequentity::Track>(tool.subject())) {
            Registry.assign<Sequentity::Track>(tool.subject(), name.text, color);
        }

        auto origin = Registry.get<Position>(tool.subject());
        auto* data = new ToolEventData{}; {
            data->start = time;
            data->input[time] = tool.input();
            data->type = tool.type();
            data->origin = origin;
        }

        auto& track = Registry.get<Sequentity::Track>(tool.subject());
        bool is_new_channel = !Sequentity::HasChannel(track, tool.eventType());
        auto& channel = Sequentity::PushChannel(track, tool.eventType());

        if (is_new_channel) {
            channel.label = tool.name();
            channel.color = tool.color();
        }

        Sequentity::PushEvent(channel, {
            time,
            1,          /* length= */
            color,
            tool.eventType(),
            static_cast<void*>(data)
        });
    }

    else if (tool.state() == ToolState_Active) {
        auto& track = Registry.get<Sequentity::Track>(tool.subject());
        
        if (!track.channels.count(tool.eventType())) {
            Warning() << "This is a tool bug";
            return;
        }

        auto& channel = track.channels[tool.eventType()];
        auto& event = channel.events.back();

        auto data = static_cast<ToolEventData*>(event.data);

        // Update existing data
        data->input[time] = tool.input();
        event.length = time - event.time + 1;
    }

    else if (tool.state() == ToolState_Deactivated) {
        Debug() << "..end";
    }
}



/**
 * @brief The simplest possible tool
 *
 *
 */
struct SelectContext : public ToolContext {
    inline ToolType type() const override  { return ToolType::Select; }
    inline EventType eventType() const override  { return SelectEvent; }
    inline const char* name() const override  { return "Select"; }
    inline ImVec4 color() const override  { return ImColor::HSV(0.0f, 0.75f, 0.75f); }
};


struct ScrubContext : public ToolContext {
    inline ToolType type() const override  { return ToolType::Scrub; }
    inline EventType eventType() const override  { return ScrubEvent; }
    inline const char* name() const override  { return "Scrub"; }
};



/**
 * @brief Translate an entity
 *
 *      __________ 
 *     |          |
 *     |          | ----------->   
 *     |          |
 *     |__________|
 *
 *
 */
struct TranslateContext : public ToolContext {
    inline ToolType type() const override  { return ToolType::Translate; }
    inline EventType eventType() const override  { return TranslateEvent; }
    inline const char* name() const override  { return "Translate"; }
    inline ImVec4 color() const override { return ImColor::HSV(0.0f, 0.75f, 0.75f); }

    void setup() {
        Debug() << "Setting Translate mouse cursor..";
        Debug() << "Setting Translate tool tips..";
    }

    bool update(InputPosition2D input) {
        Registry.reset<Tooltip>();

        if (Registry.valid(_subject)) {
            if (!Registry.has<MoveIntent>(_subject)) {
                Registry.assign<MoveIntent>(_subject, input.delta.x, input.delta.y);

            } else {
                auto& intent = Registry.get<MoveIntent>(_subject);
                intent.x += input.delta.x;
                intent.y += input.delta.y;
            }

            _state = ToolState_Active;
            _input = input;

            return true;
        }

        else {
            // Let the user know what happens once clicked
            Registry.view<Hovered>().each([](auto entity, const auto) {
                Registry.assign<Tooltip>(entity, "Drag to translate");
            });

            _state = ToolState_None;
        }

        return false;
    }
};


/**
 * @brief Rotate an entity
 *                  __
 *      __________     \
 *     |          |     v
 *     |          |   
 *     |          |
 *     |__________|
 *  ^
 *   \___
 *
 */
struct RotateContext : public ToolContext {
    inline ToolType type() const override  { return ToolType::Rotate; }
    inline EventType eventType() const override  { return RotateEvent; }
    inline const char* name() const override  { return "Rotate"; }
    inline ImVec4 color() const override { return ImColor::HSV(0.33f, 0.75f, 0.75f); }

    bool update(InputPosition2D input) {
        Registry.reset<Tooltip>();

        if (Registry.valid(_subject)) {
            if (!Registry.has<RotateIntent>(_subject)) {
                Registry.assign<RotateIntent>(_subject, input.delta.x);

            } else {
                auto& intent = Registry.get<RotateIntent>(_subject);
                intent.angle += input.delta.x;
            }

            _state = ToolState_Active;
            _input = input;

            return true;
        }

        else {
            // Let the user know what happens once clicked
            Registry.view<Hovered>().each([](auto entity, const auto) {
                Registry.assign<Tooltip>(entity, "Drag to rotate");
            });

            _state = ToolState_None;
        }

        return false;
    }
};



/**
 * @brief Scale an entity
 *
 *   \              /
 *    \ __________ /
 *     |          |
 *     |          |
 *     |          |
 *     |__________|
 *    /            \
 *   /              \
 *
 */
struct ScaleContext : public ToolContext {
    inline ToolType type() const override  { return ToolType::Scale; }
    inline EventType eventType() const override  { return ScaleEvent; }
    inline const char* name() const override  { return "Scale"; }
    inline ImVec4 color() const override { return ImColor::HSV(0.52f, 0.75f, 0.50f); }

    bool update(InputPosition2D input) {
        Registry.reset<Tooltip>();

        if (Registry.valid(_subject)) {
            if (!Registry.has<ScaleIntent>(_subject)) {
                Registry.assign<ScaleIntent>(_subject, input.delta.x);

            } else {
                auto& intent = Registry.get<ScaleIntent>(_subject);
                intent.scale += input.delta.x;
            }

            _state = ToolState_Active;
            _input = input;

            return true;
        }

        else {
            // Let the user know what happens once clicked
            Registry.view<Hovered>().each([](auto entity, const auto) {
                Registry.assign<Tooltip>(entity, "Drag to scale");
            });

            _state = ToolState_None;
        }

        return false;
    }
};
