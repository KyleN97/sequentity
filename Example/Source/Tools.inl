/*

Tools
-----

A "tool" or "tool context" represents a mode within which
input is handled. Tools are the primary mechanism with
which users interact with your data. 

*/

#include <vector>
#include <array>
#include <map>

struct Tooltip { const char* text; };

namespace Tool {

enum class Type : std::uint8_t {
    Select,
    DragSelect,
    LassoSelect,

    Translate,
    Rotate,
    Scale,

    Scrub,
};

enum class Device : std::uint8_t {
    Mouse,
    Keyboard,
    Gamepad,
    Touch,
    WacomPen,
    WacomTouch,
};

// From e.g. Wacom tablet
struct InputPressure  { float strength; };
struct InputPitch  { float angle; };
struct InputYaw  { float angle; };

// From e.g. Mouse or WASD keys
struct InputPosition2D  {
    Position absolute { 0, 0 };
    Position relative { 0, 0 };
    Position delta { 0, 0 };
};

struct InputPosition3D {
    Position absolute { 0, 0 };
    Position relative { 0, 0 };
};

// From e.g. WASD keys or D-PAD on XBox controller
enum class InputDirection2D : std::uint8_t { Left = 0, Up, Right, Down };
enum class InputDirection3D : std::uint8_t { Left = 0, Up, Right, Down, Forward, Backward };

/**
 * @brief Application data generated by these tools
 *
 * In addition to each Sequentity event, there is also our internal
 * application data, carried by events via a void*
 *
 */
struct EventData {
    Type type;
    
    // Keep track of where input starts in out input map
    int start { 0 };
    Position origin { 0, 0 };
    std::unordered_map<int, InputPosition2D> input;
};


// Possible event types
enum EventType : Sequentity::EventType {
    InvalidEvent = 0,  // Catch uninitialised types

    SelectEvent,
    LassoSelectEvent,
    DragSelectEvent,

    TranslateEvent,
    RotateEvent,
    ScaleEvent,

    ScrubEvent,

    MousePressEvent,
    MouseMoveEvent,
    MouseReleaseEvent,
    KeyPressEvent,
    KeyReleaseEvent,

    ToolEvent,
};


enum State : std::uint8_t {
    ToolState_None = 0,
    ToolState_Activated,
    ToolState_Active,
    ToolState_Deactivated
};


struct SetupIntent {};
struct BeginIntent {};
struct UpdateIntent { int time; };
struct PreviewIntent {};
struct FinishIntent {};
struct RecordIntent {};
struct AbortIntent {};
struct SelfDestructIntent {};

struct SelectTool {};
struct ScrubTool {};
struct TranslateTool {};
struct RotateTool {};
struct ScaleTool {};

struct Data {
    entt::entity target;

    int time;
    int startTime;
    int endTime;

    std::map<int, InputPosition2D> inputs;
};

struct Meta {
    const char* name;
    ImVec4 color;
    Type type;
    EventType eventType;
};

struct Label {
    const char* text;
};

using Color = ImVec4;


static const char* tooltype_to_char(Type type) {
    return type == Type::Select ? "Type::Select" :
           type == Type::Translate ? "Type::Translate" :
           type == Type::Rotate ? "Type::Rotate" :
           type == Type::Scale ? "Type::Scale" :
           type == Type::Scrub ? "Type::Scrub" :
                                 "Type::Unknown";
}


static const char* eventtype_to_char(EventType type) {
    return type == SelectEvent ? "SelectEvent" :
           type == TranslateEvent ? "TranslateEvent" :
           type == RotateEvent ? "RotateEvent" :
           type == ScaleEvent ? "ScaleEvent" :
           type == ScrubEvent ? "ScrubEvent" :
                                "UnknownEvent";
}



/**
 * @brief Translate an entity
 *
 *      __________ 
 *     |          |
 *     |          | ----------->   
 *     |          |
 *     |__________|
 *
 *
 */
void TranslateSystem() {
    auto setup = []() {
        Debug() << "Setting up Translate tool!";
    };

    auto begin = [](const auto& data) {
        Registry.reset<Selected>();
        Registry.assign<Selected>(data.target);

        // Carry on during update
        Registry.assign<UpdateIntent>(data.target, data.time);
    };

    auto preview = [](const auto& data) {
        Registry.assign_or_replace<Tooltip>(data.target, "Drag to translate");
    };

    auto update = [](const auto& data, const auto& intent) {
        const auto& input = data.inputs.at(intent.time);

        if (!Registry.has<MoveIntent>(data.target)) {
            Registry.assign<MoveIntent>(data.target, input.delta.x, input.delta.y);
        }

        else {
            auto& move = Registry.get<MoveIntent>(data.target);
            move.x += input.delta.x;
            move.y += input.delta.y;
        }
    };

    auto finish = [](const auto& data) {
    };

    Registry.view<TranslateTool, SetupIntent>().less(setup);
    Registry.view<TranslateTool, Data, BeginIntent>().less(begin);
    Registry.view<TranslateTool, Data, PreviewIntent>().less(preview);
    Registry.view<TranslateTool, Data, UpdateIntent>().less(update);
    Registry.view<TranslateTool, Data, FinishIntent>().less(finish);
}


/**
 * @brief Rotate an entity
 *                  __
 *      __________     \
 *     |          |     v
 *     |          |   
 *     |          |
 *     |__________|
 *  ^
 *   \___
 *
 */
void RotateSystem() {
    auto begin = [](const auto& data) {
        Registry.reset<Selected>();
        Registry.assign<Selected>(data.target);

        // Carry on during update
        Registry.assign<UpdateIntent>(data.target, data.time);
    };

    auto preview = [](const auto& data) {
        Registry.assign_or_replace<Tooltip>(data.target, "Drag to rotate");
    };

    auto update = [](const auto& data, const auto& intent) {
        const auto& input = data.inputs.at(intent.time);

        if (!Registry.has<RotateIntent>(data.target)) {
            Registry.assign<RotateIntent>(data.target, input.delta.x);
        
        // Intent may already have been added by an event or simultaneous tool
        } else {
            auto& rotate = Registry.get<RotateIntent>(data.target);
            rotate.angle += input.delta.x;
        }
    };

    auto finish = [](const auto& data) {
    };

    Registry.view<RotateTool, Data, BeginIntent>().less(begin);
    Registry.view<RotateTool, Data, PreviewIntent>().less(preview);
    Registry.view<RotateTool, Data, UpdateIntent>().less(update);
    Registry.view<RotateTool, Data, FinishIntent>().less(finish);
}


/**
 * @brief Scale an entity
 *
 *   \              /
 *    \ __________ /
 *     |          |
 *     |          |
 *     |          |
 *     |__________|
 *    /            \
 *   /              \
 *
 */
void ScaleSystem() {
    auto begin = [](const auto& data) {
        Registry.reset<Selected>();
        Registry.assign<Selected>(data.target);

        // Carry on during update
        Registry.assign<UpdateIntent>(data.target, data.time);
    };

    auto preview = [](const auto& data) {
        Registry.assign_or_replace<Tooltip>(data.target, "Drag to scale");
    };

    auto update = [](const auto& data, const auto& intent) {
        const auto& input = data.inputs.at(intent.time);

        if (!Registry.has<ScaleIntent>(data.target)) {
            Registry.assign<ScaleIntent>(data.target, input.delta.x);

        } else {
            auto& scale = Registry.get<ScaleIntent>(data.target);
            scale.scale += input.delta.x;
        }
    };

    auto finish = [](const auto& data) {
    };

    Registry.view<ScaleTool, Data, BeginIntent>().less(begin);
    Registry.view<ScaleTool, Data, PreviewIntent>().less(preview);
    Registry.view<ScaleTool, Data, UpdateIntent>().less(update);
    Registry.view<ScaleTool, Data, FinishIntent>().less(finish);
}


/**
 * @brief Record a device
 *
 *      __________ 
 *     |          |
 *     |          | . . . . o
 *     |          |
 *     |__________|
 *
 *
 */
void RecordSystem() {
    Registry.view<Meta, Data, RecordIntent>().less([](auto entity,
                                                      const auto& meta,
                                                      const auto& data) {
        Debug() << "Recording tool" << meta.name;

        auto [name, color] = Registry.get<Name, Color>(data.target);

        if (!Registry.has<Sequentity::Track>(data.target)) {
            Registry.assign<Sequentity::Track>(data.target, name.text, color);
        }

        // TODO: Get rid of this, it assumes every tool interation involves position
        auto origin = Registry.get<Position>(data.target);

        auto& track = Registry.get<Sequentity::Track>(data.target);
        bool is_new_channel = !Sequentity::HasChannel(track, meta.eventType);
        auto& channel = Sequentity::PushChannel(track, meta.eventType);

        if (is_new_channel) {
            channel.label = meta.name;
            channel.color = meta.color;
        }

        auto tool_copy = Registry.create();
        Registry.stomp(tool_copy, entity, Registry);

        auto& event = Sequentity::PushEvent(channel, {
            data.startTime,
            data.time - data.startTime + 1,          /* length= */
            color,
            meta.eventType,
            tool_copy
        });
    });
}


void System() {
    Registry.view<SelfDestructIntent>().each([](auto entity, const auto) {
        Debug() << "Destroying stale tool" << Registry.get<Label>(entity).text;
        Registry.destroy(entity);
    });

    TranslateSystem();
    RotateSystem();
    ScaleSystem();
    // SelectSystem();
    // ScrubSystem();

    RecordSystem();

    Registry.reset<SetupIntent>();
    Registry.reset<BeginIntent>();
    Registry.reset<UpdateIntent>();
    Registry.reset<FinishIntent>();
    Registry.reset<RecordIntent>();
    Registry.reset<PreviewIntent>();
}



}