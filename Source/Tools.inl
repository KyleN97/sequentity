#include <vector>
#include <array>

struct Activated { int time; };
struct Active { int time; };
struct Deactivated { int time; };

// Halt an ongoing iteration of enities with an `Active` component
struct Abort {};

enum class ToolType : std::uint8_t {
    Select,
    DragSelect,
    LassoSelect,

    Translate,
    Rotate,
    Scale,

    Scrub,
};

struct Tool {
    ToolType type;
    std::function<void()> system;
};

// From e.g. Wacom tablet
struct Pressure  { float strength; };
struct Pitch  { float angle; };
struct Yaw  { float angle; };

// From e.g. Mouse or WASD keys
struct InputPosition2D  {
    Position absolute { 0, 0 };
    Position relative { 0, 0 };
};

struct InputPosition3D {
    Position absolute { 0, 0 };
    Position relative { 0, 0 };
};

// From e.g. WASD keys or D-PAD on XBox controller
enum class InputDirection2D : std::uint8_t { Left = 0, Up, Right, Down };
enum class InputDirection3D : std::uint8_t { Left = 0, Up, Right, Down, Forward, Backward };


// Application data generated by these tools
struct TranslateEventData {
    Position offset;
    std::vector<Position> positions;
};


struct RotateEventData {
    float offset;
    std::vector<float> orientations;
};

struct ScaleEventData {
    float offset;
    std::vector<float> scale;
};

struct ScrubEventData {
    std::vector<int> deltas;
};


// Possible event types
enum EventType : Sequentity::EventType {
    InvalidEvent = 0,  // Catch uninitialised types

    SelectEvent,
    LassoSelectEvent,
    DragSelectEvent,

    TranslateEvent,
    RotateEvent,
    ScaleEvent,

    ScrubEvent,
};


static void SelectTool() {
    Registry.view<Name, Deactivated>().each([](auto entity, const auto& name, const auto&) {
        Registry.reset<Selected>();
        Registry.assign<Selected>(entity);
    });
}


static void TranslateTool() {
    // Handle press input of type: 2D range, relative anything with a position
    Registry.view<Name, Activated, InputPosition2D, Color, Position>().each([](
                                                                      auto entity,
                                                                      const auto& name,
                                                                      const auto& activated,
                                                                      const auto& input,
                                                                      const auto& color,
                                                                      const auto& position) {
        auto* data = new TranslateEventData{}; {
            data->offset = input.absolute - position;
            data->positions.emplace_back(input.absolute);
        }

        Sequentity::Event event; {
            event.time = activated.time + 1;
            event.length = 1;
            event.color = color;

            // Store reference to our data
            event.type = TranslateEvent;
            event.data = static_cast<void*>(data);
        }

        // Write Sequentity data..
        auto& track = Registry.get_or_assign<Sequentity::Track>(entity, name.text);
        bool has_channel = track.channels.count(TranslateEvent);

        auto& channel = track.channels[TranslateEvent];
        channel.events.push_back(event);

        if (!has_channel) {
            channel.label = "Translate";
            channel.color = ImColor::HSV(0.0f, 1.0f, 1.0f);
        }

        Registry.reset<Selected>();
        Registry.assign<Selected>(entity);
    });

    Registry.view<Name, Active, InputPosition2D, Sequentity::Track>(entt::exclude<Abort>).each([](const auto& name,
                                                                           const auto&,
                                                                           const auto& input,
                                                                           auto& track) {
        if (!track.channels.count(TranslateEvent)) { Warning() << "This should never happen"; return; }

        auto& channel = track.channels[TranslateEvent];
        auto& event = channel.events.back();

        auto data = static_cast<TranslateEventData*>(event.data);
        data->positions.emplace_back(input.absolute);
        event.length += 1;
    });

    Registry.view<Deactivated>().each([](auto entity, const auto&) {});
}


static void RotateTool() {
    Registry.view<Name, Activated, InputPosition2D, Color, Orientation>().each([](
                                                                         auto entity,
                                                                         const auto& name,
                                                                         const auto& activated,
                                                                         const auto& input,
                                                                         const auto& color,
                                                                         const auto& orientation) {
        auto* data = new RotateEventData{}; {
            data->offset = orientation;
            data->orientations.push_back(orientation);
        }

        Sequentity::Event event; {
            event.time = activated.time + 1;
            event.length = 1;
            event.color = color;

            // Store reference to our data
            event.type = RotateEvent;
            event.data = static_cast<void*>(data);
        }

        // Write Sequentity data..
        auto& track = Registry.get_or_assign<Sequentity::Track>(entity, name.text);
        bool has_channel = track.channels.count(RotateEvent);

        auto& channel = track.channels[RotateEvent];
        channel.events.push_back(event);

        if (!has_channel) {
            channel.label = "Rotate";
            channel.color = ImColor::HSV(0.33f, 1.0f, 1.0f);
        }

        Registry.reset<Selected>();
        Registry.assign<Selected>(entity);
    });

    Registry.view<Name, Active, InputPosition2D, Sequentity::Track>(entt::exclude<Abort>).each([](const auto& name,
                                                                           const auto&,
                                                                           const auto& input,
                                                                           auto& track) {
        if (!track.channels.count(RotateEvent)) { Warning() << "This should never happen"; return; }

        auto& channel = track.channels[RotateEvent];
        auto& event = channel.events.back();

        auto data = static_cast<RotateEventData*>(event.data);
        data->orientations.push_back(static_cast<float>(data->offset + input.relative.x));
        event.length += 1;
    });

    Registry.view<Deactivated>().each([](auto entity, const auto&) {});
}


static void ScaleTool() {}


static void ScrubTool() {
    // Press
    static int previous_time { 0 };
    Registry.view<Activated, InputPosition2D>().each([](const auto& activated, const auto& input) {
        auto& state = Registry.ctx<Sequentity::State>();
        previous_time = state.current_time;
    });

    // Hold
    Registry.view<Active, InputPosition2D>().each([](const auto&, const auto& input) {
        auto& state = Registry.ctx<Sequentity::State>();
        state.current_time = previous_time + input.relative.x;
    });

    // Release
    Registry.view<Deactivated>().each([](auto entity, const auto&) {});
}